# Condicionales, no tienen una estructura tan fija como otros lenguajes por ejemplo el if puede ir en una sola línea combinado con otra instrucción

edad = 25

puts "Usted debe pagar salud y pensión" if(x >= 25) # True imprime el mensaje

puts "No debe pagar impuestos" unless (x > 25) # <<x>> no es mayor que 25 y se imprime el mensaje. (Imprime esto a no ser que esto sea cierto)


# La verdad llevo dos días en que no he hecho nada, éste debía ser el día cuarto pero es como el sexto ... XD XD

if(edad >= 18)
  puts "Usted es mayor de edad puede ingresar al sitio"
else
  puts "Lo lamentamos, usted no debe ingresar a éste sitio por ser menor de edad"
end

if(edad <=15)
  puts "Usted está en la pubertad"
else if(edad >15 && edad <=18)
    puts "Usted es un adolescente"
    else
      puts"Usted es un adulto"
    end
end

# Al igual que en Java existe en Ruby el operador ternario, pero para el caso de éste último es más conciso e intuitivo.

respuesta = edad < 25 ? "No paga salud y pensión como independiente" : "Paga salud como independiente"
#               ^               ^                                                  ^
# Es decir -> Condición ? Resultado para verdadero                         Resultado para falso

edad >= 25 ? "mayor de edad" : "Menor de edad"

# elsif 

fruta = "naranja"
color = " "
if(fruta == "naranja")
  color = "Naranja"
elsif (fruta == "coco")
  color =  "cafe"
elsif(fruta == "banana")
  color = "amarillo"
else
  color = "Desconocido"
end

# case

fruta = "naranja"
case fruta
  when "naranja"
    color = "naranja"
  when "coco"
    color = "café"
  when "banana"
    color = "amarillo"
  else
    color = "Desconocido"
  end

# También se puede agregar directamente como literal

fruta = "banano"
color = case fruta
  when "coco"
    "blanco"
  when "sandia"
    "verde"
  when "banano"
    "amarillo"
  else
    "desconocido"
  end
  
  # WHILE
  
  x = 0
  while x < 100 # Mientras que x sea menor que 100
    puts x
    x+=10
  end # 0 10 20 30 40 50 60 70 80 90
  
  until x == 100 # Ejecutar esto hasta que x == 100
    puts x
    x+=10
  end # 0 10 20 30 40 50 60 70 80 90
  
  variable = []
  
  variable << until x == 50 x+=10; Se crea un Array [10 20 30 40 50 60]
  
  variable.pop until variable.empty?
  
  ######### Códe blocks
  
  def each_vowel (&code_block)
    %w{a e i o u}.each {|vowel| code_block.call(vowel)}
  end 
  
  each_vowel {|vowel| puts vowel} # a e i o u
  
        ### <<each_vowel>> es una función que recibe un código de bloque como se observa en la línea 102.
        ### para indicar que se recibe un codeblock se antepone un & al nombre de la variable, línea 98. 
        ### En la línea 99 se crea un arreglo de string, se itera sobre el y se adjunta un codeblock en el que se retorna la variable |vowel| junto con el método code_block.call(vowell)
  
def each_vowel
  %w{a e i o u}.each {|vowel| yield vowel}
end
         ### Es equivalente al anterior codeblock salvo que no se usa & o la función call si no que se se utiliza <<yield>> que simplifica y hace menos evidente para el lector de código que se trata de un codeblock.
         
# Es posible pasar máximo 1 codeblock a un método. Pueden recibir cuantos argumentos se quiera o lo que es lo mismo la función puede recibir sólo 1 codeblock y puede tener muchos parámetros.


        
        
        
